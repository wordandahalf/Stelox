#ifndef __ATA_H_
#define __ATA_H_

/*
* ATAPIO has two buses, each with a master and slave drive
* A programmer communicates to these drives using the following I/O ports as a base
*/

#define ATA_PRIMARY_IO_BASE         0x1F0
#define ATA_PRIMARY_CONTROL_BASE    0x3F6
#define ATA_SECONDARY_IO_BASE       0x170
#define ATA_SECONDARY_CONTROL_BASE  0x376

/*
* ATA registers are simply I/O ports
* They are addressed relative to a so-called port base,
* see the defines above
*
* The following use the I/O base
*/

#define ATA_REG_DATA                0x0
#define ATA_REG_ERROR               0x1
#define ATA_REG_FEATURES            0x1
#define ATA_REG_SECTOR_COUNT        0x2
#define ATA_REG_LBA_LOW             0x3
#define ATA_REG_LBA_MID             0x4
#define ATA_REG_LBA_HIGH            0x5
#define ATA_REG_SELECT_DRIVE_HEAD   0x6
#define ATA_REG_STATUS              0x7 // The STATUS register has its bits defined after the control registers
#define ATA_REG_COMMAND             0x7

// The following use the control base

#define ATA_REG_STATUS_ALTERNATE    0x0
#define ATA_REG_DRIVE_CONTROL       0x0
#define ATA_REG_DRIVE_ADDRESS       0x1

/* 
* The STATUS register (I/O base + 0x7) yields a bitfield when read
* All eight bits represent something, but these three are the only values necessary
* for a rudimentary ATA driver
*/
#define ATA_STATUS_ERR              0x00 // Indicates an error occurred
#define ATA_STATUS_DRQ              0x08 // Indicates the drive has or is ready to accept PIO data
#define ATA_STATUS_RDY              0x40 // Indicates the drive is ready.
#define ATA_STATUS_BSY              0x80 // Indicates the drive is preparing to send or receive data

/*
* See the OSDev article for a complete picture on ATA device types
*
* In short, PATA (previously known as ATA or IDE) refers to devices that support ATAPIO communication 
* SATA devices support their special protocol and the PATA IDENTIFY command;
* backwards compatibility is not required by the spec
* PATAPI devices support the ATAPI protocol
*/
typedef enum
{
    ATA_UNSCANNED_DRIVE,
    ATA_NO_DRIVE,
    ATA_PATA_DRIVE,
    ATA_SATA_DRIVE,
    ATA_PATAPI_DRIVE,
    ATA_SATAPI_DRIVE,
} AtaDriveType;

#define ATA_SIGNATURE_SATA          0xC33C
#define ATA_SIGNATURE_PATAPI        0xEB14
#define ATA_SIGNATURE_SATAPI        0x9669

/*
* This is a basic layout of the data returned by an ATAPI IDENTIFY command
*
* For an exhaustive layout, please see A.11.4.1 of the T13/2161-D Revision 5
*/
typedef struct
{
    uint16_t        flags;
    uint16_t        unused1[9];
    char            serial[20];
    uint16_t        unused2[3];
    char            firmware[8];
    char            model[40];
    uint16_t        sectors_per_int;
    uint16_t        unused3;
    uint16_t        capabilities[2];
	uint16_t        unused4[2];
	uint16_t        valid_ext_data;
	uint16_t        unused5[5];
	uint16_t        size_of_rw_mult;
	uint32_t        sectors_28;
	uint16_t        unused6[38];
	uint64_t        sectors_48;
	uint16_t        unused7[152];
} AtaIdentity;

typedef struct
{
    uint32_t        block_size;
    uint32_t        lba_count;
} AtaCapacity;

typedef struct
{
    uint16_t        io_base;
    uint16_t        control;
    bool            is_slave;
    AtaDriveType    type;
    AtaIdentity     identity;
    AtaCapacity     capacity;
} AtaDevice;

typedef union {
    uint8_t         command_bytes[12];
    uint16_t        command_words[6];
} AtapiCommand;

// The four ATAPIO devices, a master and a slave for each bus

static AtaDevice ata_primary_master     = {.io_base = ATA_PRIMARY_IO_BASE,      .control = ATA_PRIMARY_CONTROL_BASE,    .is_slave = false,  .type=ATA_UNSCANNED_DRIVE};
static AtaDevice ata_primary_slave      = {.io_base = ATA_PRIMARY_IO_BASE,      .control = ATA_PRIMARY_CONTROL_BASE,    .is_slave = true,   .type=ATA_UNSCANNED_DRIVE};
static AtaDevice ata_secondary_master   = {.io_base = ATA_SECONDARY_IO_BASE,    .control = ATA_SECONDARY_CONTROL_BASE,  .is_slave = false,  .type=ATA_UNSCANNED_DRIVE};
static AtaDevice ata_secondary_slave    = {.io_base = ATA_SECONDARY_IO_BASE,    .control = ATA_SECONDARY_CONTROL_BASE,  .is_slave = true,   .type=ATA_UNSCANNED_DRIVE};

/*
* ATA drives require a small delay after selection in order to push their status onto the bus
* The 400ns delay is generated by simply reading the STATUS register four times
*/
static void ata_400ns_delay(AtaDevice *device)
{
    inb(device->io_base + ATA_REG_STATUS);
    inb(device->io_base + ATA_REG_STATUS);
    inb(device->io_base + ATA_REG_STATUS);
    inb(device->io_base + ATA_REG_STATUS);
}

/*
* Soft-resets the drive
*/
static void ata_software_reset(AtaDevice *device)
{
    outb(device->control, 0x4);
    ata_400ns_delay(device);
    outb(device->control, 0x0);
}

/*
*   Waits until the BSY bit of ATA_REG_STATUS is cleared
*   Returns the value of the status register
*/
static int ata_status_wait(AtaDevice *device)
{
    uint8_t status = 0;

    while((status = inb(device->io_base + ATA_REG_STATUS)) & ATA_STATUS_BSY);

    return status;
}

/*
*   Selects the drive and waits 400ns
*/
static void ata_select_device(AtaDevice *device)
{
    outb(device->io_base + ATA_REG_SELECT_DRIVE_HEAD, 0xA0 | device->is_slave << 4);
    ata_400ns_delay(device);
}

/*
*   Detects the capacity of the provided drive, storing it into
*   'capacity' 
*/
static void atapi_detect_capacity(AtaDevice *device)
{
    if(device->type < ATA_PATAPI_DRIVE)
        return;

    ata_select_device(device);
    outb(device->io_base + ATA_REG_FEATURES, 0x0);
    outb(device->io_base + ATA_REG_LBA_MID,  0x8);
    outb(device->io_base + ATA_REG_LBA_HIGH, 0x8);
    outb(device->io_base + ATA_REG_COMMAND,  0xA0); //ATA_CMD_PACKET

    // poll
	while (1) {
		uint8_t status = inb(device->io_base + ATA_REG_STATUS);
		if ((status & ATA_STATUS_ERR)) return; // todo: error message
		if (!(status & ATA_STATUS_BSY) && (status & ATA_STATUS_RDY)) break;
	}

    // Send ATAPI READ CAPACITY command
    AtapiCommand detect_capacity;
    for(uint8_t i = 0; i < 6; i++)
        detect_capacity.command_words[i] = 0x0000;
    detect_capacity.command_bytes[0] = 0x25;

    for(uint8_t i = 0; i < 6; i++)
        outw(device->io_base, detect_capacity.command_words[i]);

    // poll
	while (1) {
		uint8_t status = inb(device->io_base + ATA_REG_STATUS);
		if ((status & ATA_STATUS_ERR)) return;
		if (!(status & ATA_STATUS_BSY) && (status & ATA_STATUS_RDY)) break;
		if ((status & ATA_STATUS_DRQ)) break;
	}

    uint16_t capacity_buffer[4];
    uint8_t *capacity_data = (uint8_t*)&device->capacity;

    // Read the capacity data into the buffer
    for(uint8_t i = 0; i < 4; i++)
    {
        capacity_buffer[i] = inw(device->io_base + ATA_REG_DATA);
    }

    // Flip the bytes and stores them in the struct
    for(int i = 7; i > -1; i--)
    {
        capacity_data[7 - i] = ((uint8_t*) capacity_buffer)[i];
    }
}

static void atapi_init_device(AtaDevice *device)
{
    if(device->type < ATA_PATAPI_DRIVE)
        return;

    outb(device->io_base + 1, 0x1);
    outb(device->control, 0x0);

    ata_select_device(device);

    outb(device->io_base + ATA_REG_COMMAND, 0xA1);
    
    ata_400ns_delay(device);

    ata_400ns_delay(device);
    ata_status_wait(device);

    uint16_t *identity_buffer = (uint16_t *)&device->identity;

    for(uint16_t i = 0; i < 256; i++)
        identity_buffer[i] = inw(device->io_base);

    atapi_detect_capacity(device);
}

/*
*   Detects the type of drive, initializing it if it is PATAPI
*   Returns -1 if there was an error, 0 if no drive was found, or 1 if a drive was found
*/
static int ata_detect_device(AtaDevice *device)
{
    if(device->type != ATA_UNSCANNED_DRIVE)
        return -1;

    ata_software_reset(device);
    ata_400ns_delay(device);
    ata_select_device(device);

    // ata_status_wait() with a timeout
    uint8_t status = 0;
    uint32_t timeout = -1;
    while(((status = inb(device->io_base + ATA_REG_STATUS)) & ATA_STATUS_BSY) & timeout) timeout--;

    if(!timeout)
    {    
        device->type = ATA_NO_DRIVE;
        return 0;
    }

    uint16_t signature = inb(device->io_base + ATA_REG_LBA_MID) | (inb(device->io_base + ATA_REG_LBA_HIGH) << 8);

    switch(signature)
    {
        case 0xFFFF:
            device->type = ATA_NO_DRIVE;
            return 0;
        case 0x0000:
            device->type = ATA_PATA_DRIVE;
            break;
        case 0xC33C:
            device->type = ATA_SATA_DRIVE;
            break;
        case 0xEB14:
            device->type = ATA_PATAPI_DRIVE;
            break;
        case 0x9669:
            device->type = ATA_SATAPI_DRIVE;
            break;
    }

    // Are SATAPI drives backwards compatible with PATAPI?
    if(device->type > ATA_SATA_DRIVE)
    {
        atapi_init_device(device);
    }

    return 1;
}

/*
*   Calls ata_detect_device() for each of the four ATA devices
*   It returns a pointer to the first device found with the provided type, or NULL
*/
static AtaDevice *ata_detect_devices(AtaDriveType type)
{
    ata_detect_device(&ata_primary_master);
    ata_detect_device(&ata_primary_slave);
    ata_detect_device(&ata_secondary_master);
    ata_detect_device(&ata_secondary_slave);

    if(ata_primary_master.type == type)
        return &ata_primary_master;
    if(ata_primary_slave.type == type)
        return &ata_primary_slave;
    if(ata_secondary_master.type == type)
        return &ata_secondary_master;
    if(ata_secondary_slave.type == type)
        return &ata_secondary_slave;

    return NULL;
}

static void atapi_read_sector(AtaDevice *device, uint32_t lba, uint8_t sectors, uint8_t *buffer)
{
    if(device->type < ATA_PATAPI_DRIVE)
        return;
    
    ata_software_reset(device);
    ata_select_device(device);
    
    outb(device->io_base + ATA_REG_FEATURES, 0x0);

    // Reported block size is an uint32, why is only the lower half sent?
    outb(device->io_base + ATA_REG_LBA_MID,  device->capacity.block_size & 0xFF);
    outb(device->io_base + ATA_REG_LBA_HIGH, device->capacity.block_size >> 8);
    outb(device->io_base + ATA_REG_COMMAND,  0xA0); // ATA_CMD_PACKET

    // poll
	while (1) {
		uint8_t status = inb(device->io_base + ATA_REG_STATUS);
		if ((status & ATA_STATUS_ERR)) return; // todo: error message
		if (!(status & ATA_STATUS_BSY) && (status & ATA_STATUS_DRQ)) break;
	}

    AtapiCommand command;
    command.command_bytes[0] = 0x28; // ATAPI_CMD_READ
    command.command_bytes[1] = 0x0;
	command.command_bytes[2] = (lba >> 0x18) & 0xFF;
	command.command_bytes[3] = (lba >> 0x10) & 0xFF;
	command.command_bytes[4] = (lba >> 0x08) & 0xFF;
	command.command_bytes[5] = (lba >> 0x00) & 0xFF;
	command.command_bytes[6] = sectors >> 16;
	command.command_bytes[7] = sectors >> 8;
	command.command_bytes[8] = sectors; /* bit 0 = PMI (0, last sector) */
	command.command_bytes[9] = 0; /* control */
	command.command_bytes[10] = 0;
	command.command_bytes[11] = 0;

    for(uint8_t i = 0; i < 6; i++)
        outw(device->io_base, command.command_words[i]);

    for(uint8_t i = 0; i < sectors; i++)
    {
        // poll
        while (1) {
            uint8_t status = inb(device->io_base + ATA_REG_STATUS);
            if ((status & ATA_STATUS_ERR)) return; // todo: error message
            if (!(status & ATA_STATUS_BSY) && (status & ATA_STATUS_DRQ)) break;
        }

        uint16_t read_word = 0;
        for(uint32_t i = 0; i < (device->capacity.block_size / 2); i += 2)
        {
            read_word = inw(device->io_base);

            buffer[i] = read_word & 0xFF;
            buffer[i + 1] = read_word >> 8;
        }

        buffer += device->capacity.block_size;

        // poll
        while (1) {
            uint8_t status = inb(device->io_base + ATA_REG_STATUS);
            if ((status & ATA_STATUS_ERR)) return; // todo: error message
            if (!(status & ATA_STATUS_BSY) && (status & ATA_STATUS_RDY)) break;
        }
    }
}

#endif